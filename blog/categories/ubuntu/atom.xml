<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ubuntu | Like的世界]]></title>
  <link href="http://www.malike.net.cn/blog/categories/ubuntu/atom.xml" rel="self"/>
  <link href="http://www.malike.net.cn/"/>
  <updated>2016-07-10T19:10:18+00:00</updated>
  <id>http://www.malike.net.cn/</id>
  <author>
    <name><![CDATA[Like Ma]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[nvm简介——Debian/Ubuntu中管理多版本Node.js]]></title>
    <link href="http://www.malike.net.cn/blog/2016/06/09/nvm-tutorial/"/>
    <updated>2016-06-09T00:00:00+00:00</updated>
    <id>http://www.malike.net.cn/blog/2016/06/09/nvm-tutorial</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/creationix/nvm">nvm</a>是管理Node.js版本的工具，它支持在多个Node.js版本间切换。</p>

<h2>一、安装nvm</h2>

<pre><code class="bash">git clone https://github.com/creationix/nvm.git ~/.nvm
cd ~/.nvm
git checkout `git describe --abbrev=0 --tags
</code></pre>

<p>激活nvm</p>

<pre><code class="bash">. $NVM_DIR/nvm.sh
</code></pre>

<p>为了每次登录后自动激活nvm，需要将<code>NMV_DIR</code>、<code>nvm.sh</code>和补齐加入bash的~/.bashrc（或zsh的~/.zshrc）</p>

<pre><code class="bash">export NVM_DIR=~/.nvm
[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh"
[ -r $NVM_DIR/bash_completion ] &amp;&amp; . $NVM_DIR/bash_completion
</code></pre>

<h2>二、nvm常用命令</h2>

<h3>列表可安装的Node.js版本</h3>

<pre><code class="bash">nvm ls-remote
</code></pre>

<p>除了Node.js官方版本，还支持io.js</p>

<h3>安装指定版本的Node.js</h3>

<pre><code class="bash">nvm install 6.2.1
</code></pre>

<p>它会自动下载指定版本的Node.js二进制包（不需要编译源码），安装在~/.nvm/versions/node</p>

<h3>卸载指定版本的Node.js</h3>

<pre><code class="bash">nvm uninstall 6.2.1
</code></pre>

<h3>设置shell的Node.js版本</h3>

<pre><code class="bash">nvm use 6.2.1
</code></pre>

<p>它将Node.js指定版本的bin路径加入PATH.</p>

<p>还原环境变量PATH</p>

<pre><code class="bash">nvm deactivate
</code></pre>

<h3>迁移npm至新版本的Node.js</h3>

<pre><code>nvm install node --reinstall-packages-from=node
</code></pre>

<p>或</p>

<pre><code>nvm install v6.2.1 --reinstall-packages-from=5.0
</code></pre>

<h3>.nvmrc</h3>

<p>它存储在工程根目录中，用于记录该工程依赖的Node.js版本</p>

<pre><code class="bash">echo 6.2.1 &gt; .nvmrc
</code></pre>

<p>进入工程目录（当前目录），运行</p>

<pre><code class="bash">nvm use
</code></pre>

<p>将根据.nvmrc指定shell的Nodejs版本</p>

<h2>三、升级nvm</h2>

<pre><code class="bash">cd $NVM_DIR
git fetch origin
git checkout `git describe --abbrev=0 --tags`
</code></pre>

<p>升级完成后，需要重新激活nvm</p>

<pre><code class="bash">. $NVM_DIR/nvm.sh
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pyenv简介——Debian/Ubuntu中管理多版本Python]]></title>
    <link href="http://www.malike.net.cn/blog/2016/05/21/pyenv-tutorial/"/>
    <updated>2016-05-21T00:00:00+00:00</updated>
    <id>http://www.malike.net.cn/blog/2016/05/21/pyenv-tutorial</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/yyuu/pyenv">pyenv</a>是管理Python版本的工具，它支持在多个Python版本间切换。</p>

<h2>一、安装pyenv</h2>

<pre><code class="bash">git clone https://github.com/yyuu/pyenv.git ~/.pyenv
</code></pre>

<p>将<code>PYENV_ROOT</code>和<code>pyenv init</code>加入bash的~/.bashrc（或zsh的~/.zshrc）</p>

<pre><code class="bash">echo 'export PATH=~/.pyenv/bin:$PATH' &gt;&gt; ~/.bashrc
echo 'export PYENV_ROOT=~/.pyenv' &gt;&gt; ~/.bashrc
echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.bashrc
</code></pre>

<h2>二、pyenv常用命令</h2>

<h3>列表可安装的Python版本</h3>

<pre><code class="python">pyenv install -l
</code></pre>

<p>除了Python官方版本，还支持</p>

<ul>
<li>anaconda</li>
<li>ironpython</li>
<li>jython</li>
<li>miniconda</li>
<li>pypy</li>
<li>stackless</li>
</ul>


<h3>安装指定版本的Python</h3>

<pre><code class="bash">pyenv install 3.5.1
pyenv rehash
</code></pre>

<p>它会自动下载并编译指定版本的Python源码，这需要系统安装：</p>

<pre><code class="bash">sudo apt-get install -y build-essential zlib1g-dev libssl-dev
</code></pre>

<p>还可选择安装：</p>

<pre><code class="bash">sudo apt-get install libsqlite3-dev libbz2-dev  libreadline-dev
</code></pre>

<p>安装完成后：</p>

<ul>
<li>源码（如~/Python-3.5.1.tar.gz）缓存在.pyenv/cache目录中，在安装完后可手动删除。</li>
<li>Python版本安装在~/.pyenv/versions目录中。</li>
</ul>


<h3>卸载指定版本的Python</h3>

<pre><code class="bash">pyenv unstall 3.5.1
</code></pre>

<h3>设置shell的Python版本</h3>

<pre><code class="bash">pyenv shell 3.5.1
</code></pre>

<p>等同于</p>

<pre><code class="bash">export PYENV_VERSION=3.5.1
</code></pre>

<p>清除<code>PYENV_VERSION</code></p>

<pre><code class="bash">pyenv shell --unset
</code></pre>

<h2>三、安装pyenv-virtualenv</h2>

<p>pyenv-virtual是pyenv的插件，它支持管理多个virtualenv</p>

<pre><code class="bash">git clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv
echo 'eval "$(pyenv virtualenv-init -)"' &gt;&gt; ~/.bash_profile
</code></pre>

<h3>创建virtualenv</h3>

<pre><code class="bash">pyenv virtualenv 3.5.1 aiohttp-virtual-env
</code></pre>

<ul>
<li>创建aiohttp-virtual-env之前，须先安装Python 3.5.1（通过系统或pyenv安装）。</li>
<li>aiohttp-virtual-env存储在~/.pyenv/versions/3.5.1/envs目录中，且在~/.pyenv/versions目录中建立同名符号链接。</li>
</ul>


<h3>删除virtualenv</h3>

<pre><code class="bash">pyenv uninstall aiohttp-virtual-env
</code></pre>

<h3>列表virtualenv</h3>

<pre><code class="bash">pyenv virtualenvs
</code></pre>

<h3>激活/禁用virtualenv</h3>

<pre><code class="bash">pyenv activate aiohttp-virtual-env
pyenv deactivate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH翻墙集群]]></title>
    <link href="http://www.malike.net.cn/blog/2015/03/15/ssh-proxy-cluster/"/>
    <updated>2015-03-15T13:30:43+00:00</updated>
    <id>http://www.malike.net.cn/blog/2015/03/15/ssh-proxy-cluster</id>
    <content type="html"><![CDATA[<p>SSH动态代理是国内较为常见的翻墙方法。正如<a href="/blog/2014/10/27/ssh-tunnel-tutorial/">SSH隧道简介</a>所说，它存在不少有优点。</p>

<p>然而在实际使用中，它存在如下缺点：</p>

<ul>
<li>与PPTP等VPN协议相比，它的连接不稳定。前者应该具备协议级断线重传机制。</li>
<li>基于廉价VPS，导致它的连接不稳定。而且廉价VPS容易掉线，有时需要用户自己找在线客户修复，进一步延长了掉线时间。</li>
<li>由于上述缺点，不适合小型公司多人使用。</li>
</ul>


<p>在大概2年前，我摸索出SSH动态代理集群的办法。并将之部署于我所服务的公司，成功负载了20-30人日常翻墙学习与工作的需求。</p>

<h2>原理</h2>

<p>SSH动态代理，即为SOCK5代理，所以我们需要的是SOCK5集群。</p>

<p>若搜索<a href="https://www.google.com/search?hl=en&amp;q=socks+5+load+balance">socks 5 load balance</a>不难发现一些有用信息：</p>

<p><a href="http://serverfault.com/questions/517971/what-is-the-best-way-to-load-balance-multiple-sock5-proxys-on-seperate-vms-in-t">What is the best way to load balance multiple sock5 proxys on seperate VM&rsquo;s in the same datacenter?</a></p>

<p>我将分别介绍3种方法搭建SOCK5集群：</p>

<ol>
<li>利用第三方模块<a href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module</a>。</li>
<li>Nginx 1.9开始支持<a href="http://nginx.com/resources/admin-guide/tcp-load-balancing/">TCP Load Balancing</a>。</li>
<li><a href="http://www.haproxy.org/">HAProxy</a></li>
</ol>


<p>关于SSH动态代理的配置方法，请参看<a href="/blog/2014/12/23/autossh-tutorial/">AutoSSH简介</a></p>

<h2>nginx_tcp_proxy_module的配置方法</h2>

<p>Ubuntu的Nginx并没有将nginx_tcp_proxy_module编译进去。为了简化安装，我基于Ubuntu的Nginx包，做了Nginx的<a href="https://launchpad.net/~likemartinma/+archive/ubuntu/net">PPA</a>:</p>

<ul>
<li>升级Nginx版本</li>
<li>加入nginx_tcp_proxy_module</li>
</ul>


<p>添加我的PPA</p>

<pre><code class="bash">sudo add-apt-repository ppa:likemartinma/net
sudo apt-get -y update
</code></pre>

<p>若未安装nginx，则</p>

<pre><code class="bash">sudo apt-get install -y nginx
</code></pre>

<p>若已安装nginx，则</p>

<pre><code class="bash">sudo apt-get -y upgrade
</code></pre>

<p>在/etc/nginx/nginx.conf中，增加如下内容：</p>

<pre><code class="nginx">tcp {
    access_log /var/log/nginx/tcp_access.log;

    upstream ssh_cluster {
        # simple round-robin
        server 127.0.0.1:12345;
        server 127.0.0.1:12346;
        server 127.0.0.1:12347;

        check interval=3000 rise=2 fall=5 timeout=1000;
    }

    server {
        listen 9999;
        proxy_pass ssh_cluster;
    }
}
</code></pre>

<p>为了查看集群的状态，在/etc/nginx/sites-enabled/default的中，增加如下内容：</p>

<pre><code class="nginx">server {
    ...

    location /status {
        tcp_check_status;
    }
}
</code></pre>

<p>重启Nginx:</p>

<pre><code>service nginx restart
</code></pre>

<p>如此，访问http://&lt;cluster IP&gt;/status将能查看集群的详细状态。</p>

<h2>Nginx 1.9的配置方法</h2>

<p>Ubuntu 15.10之前的官方Nginx版本都小于1.9，须通过ppa:nginx/development升级nginx。</p>

<p>添加ppa:nginx/development</p>

<pre><code class="bash">sudo add-apt-repository ppa:nginx/development
sudo apt-get -y update
</code></pre>

<p>若未安装nginx，则</p>

<pre><code class="bash">sudo apt-get install -y nginx
</code></pre>

<p>若已安装nginx，则</p>

<pre><code class="bash">sudo apt-get -y upgrade
</code></pre>

<p>在/etc/nginx/nginx.conf中，增加如下内容：</p>

<pre><code class="nginx">stream {
    upstream ssh_cluster {
        least_conn;
        server 127.0.0.1:12345;
        server 127.0.0.1:12346;
        server 127.0.0.1:12347;
    }

    server {
        listen 9999;
        proxy_pass ssh_cluster;
    }
}
</code></pre>

<p>重启Nginx:</p>

<pre><code>service nginx restart
</code></pre>

<h2>HAProxy的配置方法</h2>

<p>安装haproxy</p>

<pre><code>sudo apt-get install -y haproxy
</code></pre>

<p>在/etc/haproxy/haproxy.cfg中，增加如下内容：</p>

<pre><code>frontend socks5
    mode tcp
    bind *:9999
    default_backend ssh_cluster

backend ssh_cluster
    mode tcp
    balance roundrobin
    server vps1 127.0.0.1:12345 weight 1 check inter 30000
    server vps2 127.0.0.1:12346 weight 1 check inter 30000
    server vps3 127.0.0.1:12347 weight 1 check inter 30000
</code></pre>

<p>为了查看集群的状态，在/etc/haproxy/haproxy.cfg中，增加如下内容：</p>

<pre><code>listen stats :9090
    balance
    mode http
    stats enable
    stats auth admin:admin
</code></pre>

<p>默认安装，haproxy处于不活动状态，须要激活它。</p>

<p>在/etc/default/haproxy中，修改如下行：</p>

<pre><code>ENABLED=1
</code></pre>

<p>最后，启动haproxy:</p>

<pre><code>service haproxy start
</code></pre>

<p>如此，访问http://&lt;cluster IP&gt;:9090/haproxy?stats将能查看集群的详细状态。</p>

<h2>总结</h2>

<ul>
<li>nginx_tcp_proxy_module有简单的集群状态页面。</li>
<li>nginx 1.9没有集群状态查页面，仅能通过错误日志/var/log/ngnix/error.log来查看掉线的集群节点。</li>
<li>haproxy不仅有完善的集群状态页面，而且不需要任何PPA，应该是最佳选择。</li>
<li>上述3种方法都缺乏认证机制，只能部署于家庭或企业内网。当然也可以部署于个人电脑，事实上，我就是这样使用的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AutoSSH简介]]></title>
    <link href="http://www.malike.net.cn/blog/2014/12/23/autossh-tutorial/"/>
    <updated>2014-12-23T00:00:00+00:00</updated>
    <id>http://www.malike.net.cn/blog/2014/12/23/autossh-tutorial</id>
    <content type="html"><![CDATA[<p><a href="http://www.harding.motd.ca/autossh/">autossh</a> (Automatically restart SSH sessions and tunnels)，它在运行的时候启动一个SSH进程，并监控该进程的健康状况；当SSH进程崩溃或停止通信时，它将重启动SSH进程。</p>

<h2>命令选项</h2>

<pre><code class="bash">autossh [-V] [-M port[:echo_port]] [-f] [SSH_OPTIONS]
</code></pre>

<ul>
<li><p><strong>-M port[:echo_port]</strong> 指定监控端口（和echo端口，默认为前者加1）。</p>

<ul>
<li>若希望使远程标准inetd的echo服务（默认端口为7），则指定echo_port，仅需服务监听地址为localhost。</li>
<li>若port设置为0，则将禁用监控功能。仅在ssh退出后重启它。</li>
</ul>
</li>
<li><p><strong>-f</strong> 使autossh在后台运行。</p></li>
</ul>


<p>另外，autossh还提供了一组环境变量来控制其行为, 这里仅介绍几个有代表性的，其可以man autossh</p>

<ul>
<li><strong>AUTOSSH_FIRST_POLL</strong> 指定首次论询测试时间。</li>
<li><strong>AUTOSSH_POLL</strong> 指定连接论询时间，默认600。若该值小于两次网络超时（默认15秒），则网络超将被调整为该值的1/2</li>
<li><strong>AUTOSSH_GATETIME</strong> 指定等待SSH连接成功建立的时间，默认30秒，超时表示首次运行失败，将退出autossh。若设为0，则禁用该功能，通常用于启动时运行autossh。</li>
<li><strong>AUTOSSH_MAXLIFETIME</strong> 指autossh最长运行时间，达到该时间，autossh将退出，并杀死SSH进程。</li>
<li><strong>AUTOSSH_MAXSTART</strong> 指定SSH最大启动次数。默认-1，表示无限制。</li>
</ul>


<h2>Ubuntu配置方法</h2>

<p>基于Ubuntu 12.04或14.04，以SSH动态代理（即SSH翻墙）为例。init script和Upstart都可以将autossh变成服务，然Upstart的<em>respawn</em>容错能力更强，它能在服务进程掉线，重新启动该服务。</p>

<pre><code># autossh

description "autossh daemon"

start on (net-device-up IFACE=eth0 or net-device-up IFACE=wlan0)
stop on (net-device-down IFACE=eth0 and net-device-down IFACE=wlan0)

respawn

setuid like
setgid like

exec /usr/bin/autossh -M64000 -q -N -D localhost:12348 sshproxy
</code></pre>

<ul>
<li><em>setuid</em>和<em>setgid</em>为了让autossh运行在指定的用户和用户组上。</li>
<li><em>start on</em>表示当eth0或wlan0激活时，启动autossh，<em>stop on</em>反之。其目的为避免系统启动或网络掉线时，频繁尝试启动autossh。</li>
</ul>


<h2>更好的办法</h2>

<p>最近OpenSSH都支持选项<strong>ServerAliveInterval</strong>和<strong>ServerAliveCountMax</strong>，实际为建立在SSH协议上的心跳测试。当测试失败后，SSH客户端进程将退出。通过Upstart的respawn功能重启SSH客户端进程，也能达到autossh目的。</p>

<p>仍以SSH动态代理为例：</p>

<pre><code># sshproxy

description "ssh proxy"

start on (net-device-up IFACE=eth0 or net-device-up IFACE=wlan0)
stop on (net-device-down IFACE=eth0 and net-device-down IFACE=wlan0)

respawn

setuid like
setgid like

exec /usr/bin/ssh \
    -oServerAliveInterval=300 \
    -oServerAliveCountMax=2 \
    -q -N -D localhost:12348 sshproxy
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rinse简介——Debian/Ubuntu中创建RPM安装环境]]></title>
    <link href="http://www.malike.net.cn/blog/2014/07/15/rinse-tutorial/"/>
    <updated>2014-07-15T12:34:58+00:00</updated>
    <id>http://www.malike.net.cn/blog/2014/07/15/rinse-tutorial</id>
    <content type="html"><![CDATA[<p><a href="http://collab-maint.alioth.debian.org/rinse/">Rinse</a>是一个Debian环境中创建RPM发行版本（如CentOS，Scientific Linux和openSUSE）的工具。你可以利用它轻松创建各种RPM发行版本的chroot环境。</p>

<p>以下基于Ubuntu 12.04 amd64，主要以创建CentOS 6 x86_64为例。</p>

<h2>安装Rinse</h2>

<pre><code class="sh">sudo apt-get install -y rinse
</code></pre>

<h2>创建CentOS 6</h2>

<pre><code class="sh">sudo rinse --distribution centos-6 --arch amd64 --directory centos-6
</code></pre>

<p>运行该命令将创建CentOS 6 amd64于当前工作目录的centos-6目录中。其中，</p>

<ul>
<li>&ndash;distribution指定发行版本，类似还可以centos-{4,5}， fedora-core-{4,5,6,7,8,9}和opensuse-{10.1,10.2,10.3,11.0,11.1,12.1}等。可以下述命令获取：</li>
</ul>


<pre><code class="sh">rinse --list-distributions
</code></pre>

<p>具体对应于/etc/rinse/*.packages的模板名，它们主要包含RPM包列表。换一句话说，你根据需要定制自己的模板。另一方面，你也可以通过&ndash;pkgs-dir指定不同于/etc/rinse的模板目录。</p>

<ul>
<li>&ndash;arch指定架构，amd64表示64位架构，i386表示32位架构。缺省为i386.</li>
<li>&ndash;directory指定为安装目录，安装结束后便可以chroot该目录了。</li>
</ul>


<p>另外，需要额外安装某些包，可以通过指定&ndash;add-pkg-list来完成。</p>

<h2>配置RPM缓存</h2>

<p>rinse默认使用/var/rinse/cache作为缓存目录，它大大缩短了重复运行同样命令的时间。具体通过：</p>

<ul>
<li>&ndash;cache 0指禁用缓存，缺省为1</li>
<li>&ndash;cache-dir指定不同于/var/rinse/cache作为缓存目录。</li>
<li>&ndash;clean-cache指清楚缓存</li>
</ul>


<h2>定制安装后执行脚本</h2>

<p>&ndash;after-post-install, &ndash;before-post-install和&ndash;post-install顾名思义，需要指出的是&ndash;post-install默认执行/usr/lib/rinse/<distribution>/post-install.sh.</p>

<h2>如何提高安装速度？</h2>

<p>通过修改/etc/rinse/rinse.conf中对应发行版的镜像地址可以加速安装，如CentOS 6 x86_64的镜像地址可以修改为</p>

<pre><code>http://centos.ustc.edu.cn/centos/6/os/x86_64/CentOS/
</code></pre>

<p>也可以通过&ndash;config指定不同于/etc/rinse/rinse.conf的配置文件。</p>

<p>若内网存在HTTP cache服务器（如Squid)，还可以设置环境变量http_proxy来缓存rpm以及加速安装，如：</p>

<pre><code class="sh">sudo http_proxy=http://&lt;http proxy address&gt; rinse --distribution centos-6 --arch amd64 --directory centos-6
</code></pre>
]]></content>
  </entry>
  
</feed>
